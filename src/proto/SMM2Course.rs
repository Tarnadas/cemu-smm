// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protobuf-codegen-pure=3.0.0-pre
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `SMM2Course.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SMM2Course {
    // message fields
    pub version: u32,
    pub header: ::protobuf::MessageField<SMM2CourseHeader>,
    pub course_area: ::protobuf::MessageField<SMM2CourseArea>,
    pub course_sub_area: ::protobuf::MessageField<SMM2CourseArea>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SMM2Course {
    fn default() -> &'a SMM2Course {
        <SMM2Course as ::protobuf::Message>::default_instance()
    }
}

impl SMM2Course {
    pub fn new() -> SMM2Course {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &SMM2Course| { &m.version },
            |m: &mut SMM2Course| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SMM2CourseHeader>(
            "header",
            |m: &SMM2Course| { &m.header },
            |m: &mut SMM2Course| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SMM2CourseArea>(
            "course_area",
            |m: &SMM2Course| { &m.course_area },
            |m: &mut SMM2Course| { &mut m.course_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SMM2CourseArea>(
            "course_sub_area",
            |m: &SMM2Course| { &m.course_sub_area },
            |m: &mut SMM2Course| { &mut m.course_sub_area },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SMM2Course>(
            "SMM2Course",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for SMM2Course {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.course_area {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.course_sub_area {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.version = is.read_uint32()?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.header)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.course_area)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.course_sub_area)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.course_area.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.course_sub_area.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_uint32(1, self.version)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.course_area.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.course_sub_area.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SMM2Course {
        SMM2Course::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static SMM2Course {
        static instance: SMM2Course = SMM2Course {
            version: 0,
            header: ::protobuf::MessageField::none(),
            course_area: ::protobuf::MessageField::none(),
            course_sub_area: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SMM2Course {
    fn clear(&mut self) {
        self.version = 0;
        self.header.clear();
        self.course_area.clear();
        self.course_sub_area.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SMM2Course {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SMM2Course {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SMM2CourseHeader {
    // message fields
    pub modified: u64,
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub start_y: u32,
    pub finish_y: u32,
    pub finish_x: u32,
    pub time: u32,
    pub game_style: ::protobuf::ProtobufEnumOrUnknown<smm2course_header::GameStyle>,
    pub clear_condition_type: ::protobuf::ProtobufEnumOrUnknown<smm2course_header::ClearConditionType>,
    pub clear_condition: u32,
    pub clear_condition_amount: u32,
    pub clear_check_tries: u32,
    pub clear_check_time: u32,
    pub game_version: u32,
    pub management_flags: u32,
    pub creation_id: u32,
    pub upload_id: u64,
    pub completion_version: u32,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SMM2CourseHeader {
    fn default() -> &'a SMM2CourseHeader {
        <SMM2CourseHeader as ::protobuf::Message>::default_instance()
    }
}

impl SMM2CourseHeader {
    pub fn new() -> SMM2CourseHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modified",
            |m: &SMM2CourseHeader| { &m.modified },
            |m: &mut SMM2CourseHeader| { &mut m.modified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &SMM2CourseHeader| { &m.title },
            |m: &mut SMM2CourseHeader| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &SMM2CourseHeader| { &m.description },
            |m: &mut SMM2CourseHeader| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_y",
            |m: &SMM2CourseHeader| { &m.start_y },
            |m: &mut SMM2CourseHeader| { &mut m.start_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "finish_y",
            |m: &SMM2CourseHeader| { &m.finish_y },
            |m: &mut SMM2CourseHeader| { &mut m.finish_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "finish_x",
            |m: &SMM2CourseHeader| { &m.finish_x },
            |m: &mut SMM2CourseHeader| { &mut m.finish_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &SMM2CourseHeader| { &m.time },
            |m: &mut SMM2CourseHeader| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "game_style",
            |m: &SMM2CourseHeader| { &m.game_style },
            |m: &mut SMM2CourseHeader| { &mut m.game_style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clear_condition_type",
            |m: &SMM2CourseHeader| { &m.clear_condition_type },
            |m: &mut SMM2CourseHeader| { &mut m.clear_condition_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clear_condition",
            |m: &SMM2CourseHeader| { &m.clear_condition },
            |m: &mut SMM2CourseHeader| { &mut m.clear_condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clear_condition_amount",
            |m: &SMM2CourseHeader| { &m.clear_condition_amount },
            |m: &mut SMM2CourseHeader| { &mut m.clear_condition_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clear_check_tries",
            |m: &SMM2CourseHeader| { &m.clear_check_tries },
            |m: &mut SMM2CourseHeader| { &mut m.clear_check_tries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clear_check_time",
            |m: &SMM2CourseHeader| { &m.clear_check_time },
            |m: &mut SMM2CourseHeader| { &mut m.clear_check_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "game_version",
            |m: &SMM2CourseHeader| { &m.game_version },
            |m: &mut SMM2CourseHeader| { &mut m.game_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "management_flags",
            |m: &SMM2CourseHeader| { &m.management_flags },
            |m: &mut SMM2CourseHeader| { &mut m.management_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creation_id",
            |m: &SMM2CourseHeader| { &m.creation_id },
            |m: &mut SMM2CourseHeader| { &mut m.creation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &SMM2CourseHeader| { &m.upload_id },
            |m: &mut SMM2CourseHeader| { &mut m.upload_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completion_version",
            |m: &SMM2CourseHeader| { &m.completion_version },
            |m: &mut SMM2CourseHeader| { &mut m.completion_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SMM2CourseHeader>(
            "SMM2CourseHeader",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for SMM2CourseHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modified = is.read_uint64()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.title = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.description = is.read_string()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_y = is.read_uint32()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.finish_y = is.read_uint32()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.finish_x = is.read_uint32()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time = is.read_uint32()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_style = is.read_enum_or_unknown()?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_condition_type = is.read_enum_or_unknown()?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_condition = is.read_uint32()?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_condition_amount = is.read_uint32()?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_check_tries = is.read_uint32()?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_check_time = is.read_uint32()?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_version = is.read_uint32()?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.management_flags = is.read_uint32()?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.creation_id = is.read_uint32()?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.upload_id = is.read_uint64()?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.completion_version = is.read_uint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.modified != 0 {
            my_size += ::protobuf::rt::value_size(1, self.modified, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.start_y != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_y, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.finish_y != 0 {
            my_size += ::protobuf::rt::value_size(5, self.finish_y, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.finish_x != 0 {
            my_size += ::protobuf::rt::value_size(6, self.finish_x, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(7, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.game_style != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_header::GameStyle::M1) {
            my_size += ::protobuf::rt::enum_or_unknown_size(8, self.game_style);
        }
        if self.clear_condition_type != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_header::ClearConditionType::NONE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(9, self.clear_condition_type);
        }
        if self.clear_condition != 0 {
            my_size += ::protobuf::rt::value_size(10, self.clear_condition, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.clear_condition_amount != 0 {
            my_size += ::protobuf::rt::value_size(11, self.clear_condition_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.clear_check_tries != 0 {
            my_size += ::protobuf::rt::value_size(12, self.clear_check_tries, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.clear_check_time != 0 {
            my_size += ::protobuf::rt::value_size(13, self.clear_check_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.game_version != 0 {
            my_size += ::protobuf::rt::value_size(14, self.game_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.management_flags != 0 {
            my_size += ::protobuf::rt::value_size(15, self.management_flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.creation_id != 0 {
            my_size += ::protobuf::rt::value_size(16, self.creation_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.upload_id != 0 {
            my_size += ::protobuf::rt::value_size(17, self.upload_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.completion_version != 0 {
            my_size += ::protobuf::rt::value_size(18, self.completion_version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.modified != 0 {
            os.write_uint64(1, self.modified)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.start_y != 0 {
            os.write_uint32(4, self.start_y)?;
        }
        if self.finish_y != 0 {
            os.write_uint32(5, self.finish_y)?;
        }
        if self.finish_x != 0 {
            os.write_uint32(6, self.finish_x)?;
        }
        if self.time != 0 {
            os.write_uint32(7, self.time)?;
        }
        if self.game_style != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_header::GameStyle::M1) {
            os.write_enum(8, ::protobuf::ProtobufEnumOrUnknown::value(&self.game_style))?;
        }
        if self.clear_condition_type != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_header::ClearConditionType::NONE) {
            os.write_enum(9, ::protobuf::ProtobufEnumOrUnknown::value(&self.clear_condition_type))?;
        }
        if self.clear_condition != 0 {
            os.write_uint32(10, self.clear_condition)?;
        }
        if self.clear_condition_amount != 0 {
            os.write_uint32(11, self.clear_condition_amount)?;
        }
        if self.clear_check_tries != 0 {
            os.write_uint32(12, self.clear_check_tries)?;
        }
        if self.clear_check_time != 0 {
            os.write_uint32(13, self.clear_check_time)?;
        }
        if self.game_version != 0 {
            os.write_uint32(14, self.game_version)?;
        }
        if self.management_flags != 0 {
            os.write_uint32(15, self.management_flags)?;
        }
        if self.creation_id != 0 {
            os.write_uint32(16, self.creation_id)?;
        }
        if self.upload_id != 0 {
            os.write_uint64(17, self.upload_id)?;
        }
        if self.completion_version != 0 {
            os.write_uint32(18, self.completion_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SMM2CourseHeader {
        SMM2CourseHeader::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static SMM2CourseHeader {
        static instance: SMM2CourseHeader = SMM2CourseHeader {
            modified: 0,
            title: ::std::string::String::new(),
            description: ::std::string::String::new(),
            start_y: 0,
            finish_y: 0,
            finish_x: 0,
            time: 0,
            game_style: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            clear_condition_type: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            clear_condition: 0,
            clear_condition_amount: 0,
            clear_check_tries: 0,
            clear_check_time: 0,
            game_version: 0,
            management_flags: 0,
            creation_id: 0,
            upload_id: 0,
            completion_version: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SMM2CourseHeader {
    fn clear(&mut self) {
        self.modified = 0;
        self.title.clear();
        self.description.clear();
        self.start_y = 0;
        self.finish_y = 0;
        self.finish_x = 0;
        self.time = 0;
        self.game_style = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_header::GameStyle::M1);
        self.clear_condition_type = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_header::ClearConditionType::NONE);
        self.clear_condition = 0;
        self.clear_condition_amount = 0;
        self.clear_check_tries = 0;
        self.clear_check_time = 0;
        self.game_version = 0;
        self.management_flags = 0;
        self.creation_id = 0;
        self.upload_id = 0;
        self.completion_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SMM2CourseHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SMM2CourseHeader {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SMM2CourseHeader`
pub mod smm2course_header {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum GameStyle {
        M1 = 0,
        M3 = 1,
        MW = 2,
        WU = 3,
        W3 = 4,
    }

    impl ::protobuf::ProtobufEnum for GameStyle {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GameStyle> {
            match value {
                0 => ::std::option::Option::Some(GameStyle::M1),
                1 => ::std::option::Option::Some(GameStyle::M3),
                2 => ::std::option::Option::Some(GameStyle::MW),
                3 => ::std::option::Option::Some(GameStyle::WU),
                4 => ::std::option::Option::Some(GameStyle::W3),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [GameStyle] = &[
                GameStyle::M1,
                GameStyle::M3,
                GameStyle::MW,
                GameStyle::WU,
                GameStyle::W3,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 0)
        }
    }

    impl ::std::default::Default for GameStyle {
        fn default() -> Self {
            GameStyle::M1
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GameStyle {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl GameStyle {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<GameStyle>("SMM2CourseHeader.GameStyle", 0)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum ClearConditionType {
        NONE = 0,
        PARTS = 1,
        STATUS = 2,
        ACTION = 3,
    }

    impl ::protobuf::ProtobufEnum for ClearConditionType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ClearConditionType> {
            match value {
                0 => ::std::option::Option::Some(ClearConditionType::NONE),
                1 => ::std::option::Option::Some(ClearConditionType::PARTS),
                2 => ::std::option::Option::Some(ClearConditionType::STATUS),
                3 => ::std::option::Option::Some(ClearConditionType::ACTION),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ClearConditionType] = &[
                ClearConditionType::NONE,
                ClearConditionType::PARTS,
                ClearConditionType::STATUS,
                ClearConditionType::ACTION,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 1)
        }
    }

    impl ::std::default::Default for ClearConditionType {
        fn default() -> Self {
            ClearConditionType::NONE
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ClearConditionType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl ClearConditionType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ClearConditionType>("SMM2CourseHeader.ClearConditionType", 1)
        }
    }
}

#[derive(PartialEq,Clone,Default)]
#[derive(Serialize, Deserialize)]
pub struct SMM2CourseArea {
    // message fields
    pub course_theme: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::CourseTheme>,
    pub auto_scroll: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::AutoScroll>,
    pub screen_boundary: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::ScreenBoundary>,
    pub orientation: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::Orientation>,
    pub liquid_max: u32,
    pub liquid_mode: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::LiquidMode>,
    pub liquid_speed: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::LiquidSpeed>,
    pub liquid_min: u32,
    pub right_boundary: u32,
    pub top_boundary: u32,
    pub left_boundary: u32,
    pub bottom_boundary: u32,
    pub day_time: ::protobuf::ProtobufEnumOrUnknown<smm2course_area::DayTime>,
    pub object_count: u32,
    pub sound_effect_count: u32,
    pub snake_block_count: u32,
    pub clear_pipe_count: u32,
    pub piranha_creeper_count: u32,
    pub exclamation_block_count: u32,
    pub track_block_count: u32,
    pub tile_count: u32,
    pub track_count: u32,
    pub icicle_count: u32,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SMM2CourseArea {
    fn default() -> &'a SMM2CourseArea {
        <SMM2CourseArea as ::protobuf::Message>::default_instance()
    }
}

impl SMM2CourseArea {
    pub fn new() -> SMM2CourseArea {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "course_theme",
            |m: &SMM2CourseArea| { &m.course_theme },
            |m: &mut SMM2CourseArea| { &mut m.course_theme },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auto_scroll",
            |m: &SMM2CourseArea| { &m.auto_scroll },
            |m: &mut SMM2CourseArea| { &mut m.auto_scroll },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "screen_boundary",
            |m: &SMM2CourseArea| { &m.screen_boundary },
            |m: &mut SMM2CourseArea| { &mut m.screen_boundary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orientation",
            |m: &SMM2CourseArea| { &m.orientation },
            |m: &mut SMM2CourseArea| { &mut m.orientation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "liquid_max",
            |m: &SMM2CourseArea| { &m.liquid_max },
            |m: &mut SMM2CourseArea| { &mut m.liquid_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "liquid_mode",
            |m: &SMM2CourseArea| { &m.liquid_mode },
            |m: &mut SMM2CourseArea| { &mut m.liquid_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "liquid_speed",
            |m: &SMM2CourseArea| { &m.liquid_speed },
            |m: &mut SMM2CourseArea| { &mut m.liquid_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "liquid_min",
            |m: &SMM2CourseArea| { &m.liquid_min },
            |m: &mut SMM2CourseArea| { &mut m.liquid_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "right_boundary",
            |m: &SMM2CourseArea| { &m.right_boundary },
            |m: &mut SMM2CourseArea| { &mut m.right_boundary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top_boundary",
            |m: &SMM2CourseArea| { &m.top_boundary },
            |m: &mut SMM2CourseArea| { &mut m.top_boundary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "left_boundary",
            |m: &SMM2CourseArea| { &m.left_boundary },
            |m: &mut SMM2CourseArea| { &mut m.left_boundary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bottom_boundary",
            |m: &SMM2CourseArea| { &m.bottom_boundary },
            |m: &mut SMM2CourseArea| { &mut m.bottom_boundary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "day_time",
            |m: &SMM2CourseArea| { &m.day_time },
            |m: &mut SMM2CourseArea| { &mut m.day_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_count",
            |m: &SMM2CourseArea| { &m.object_count },
            |m: &mut SMM2CourseArea| { &mut m.object_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sound_effect_count",
            |m: &SMM2CourseArea| { &m.sound_effect_count },
            |m: &mut SMM2CourseArea| { &mut m.sound_effect_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snake_block_count",
            |m: &SMM2CourseArea| { &m.snake_block_count },
            |m: &mut SMM2CourseArea| { &mut m.snake_block_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clear_pipe_count",
            |m: &SMM2CourseArea| { &m.clear_pipe_count },
            |m: &mut SMM2CourseArea| { &mut m.clear_pipe_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "piranha_creeper_count",
            |m: &SMM2CourseArea| { &m.piranha_creeper_count },
            |m: &mut SMM2CourseArea| { &mut m.piranha_creeper_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exclamation_block_count",
            |m: &SMM2CourseArea| { &m.exclamation_block_count },
            |m: &mut SMM2CourseArea| { &mut m.exclamation_block_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "track_block_count",
            |m: &SMM2CourseArea| { &m.track_block_count },
            |m: &mut SMM2CourseArea| { &mut m.track_block_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tile_count",
            |m: &SMM2CourseArea| { &m.tile_count },
            |m: &mut SMM2CourseArea| { &mut m.tile_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "track_count",
            |m: &SMM2CourseArea| { &m.track_count },
            |m: &mut SMM2CourseArea| { &mut m.track_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icicle_count",
            |m: &SMM2CourseArea| { &m.icicle_count },
            |m: &mut SMM2CourseArea| { &mut m.icicle_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SMM2CourseArea>(
            "SMM2CourseArea",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for SMM2CourseArea {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.course_theme = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.auto_scroll = is.read_enum_or_unknown()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.screen_boundary = is.read_enum_or_unknown()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.orientation = is.read_enum_or_unknown()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.liquid_max = is.read_uint32()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.liquid_mode = is.read_enum_or_unknown()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.liquid_speed = is.read_enum_or_unknown()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.liquid_min = is.read_uint32()?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.right_boundary = is.read_uint32()?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.top_boundary = is.read_uint32()?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.left_boundary = is.read_uint32()?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bottom_boundary = is.read_uint32()?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.day_time = is.read_enum_or_unknown()?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.object_count = is.read_uint32()?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sound_effect_count = is.read_uint32()?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.snake_block_count = is.read_uint32()?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_pipe_count = is.read_uint32()?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.piranha_creeper_count = is.read_uint32()?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exclamation_block_count = is.read_uint32()?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.track_block_count = is.read_uint32()?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tile_count = is.read_uint32()?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.track_count = is.read_uint32()?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.icicle_count = is.read_uint32()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.course_theme != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::CourseTheme::GROUND) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.course_theme);
        }
        if self.auto_scroll != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::AutoScroll::NONE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, self.auto_scroll);
        }
        if self.screen_boundary != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::ScreenBoundary::ABOVE_LINE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, self.screen_boundary);
        }
        if self.orientation != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::Orientation::HORIZONTAL) {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, self.orientation);
        }
        if self.liquid_max != 0 {
            my_size += ::protobuf::rt::value_size(5, self.liquid_max, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.liquid_mode != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::LiquidMode::FIXED) {
            my_size += ::protobuf::rt::enum_or_unknown_size(6, self.liquid_mode);
        }
        if self.liquid_speed != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::LiquidSpeed::NONE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(7, self.liquid_speed);
        }
        if self.liquid_min != 0 {
            my_size += ::protobuf::rt::value_size(8, self.liquid_min, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right_boundary != 0 {
            my_size += ::protobuf::rt::value_size(9, self.right_boundary, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.top_boundary != 0 {
            my_size += ::protobuf::rt::value_size(10, self.top_boundary, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.left_boundary != 0 {
            my_size += ::protobuf::rt::value_size(11, self.left_boundary, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bottom_boundary != 0 {
            my_size += ::protobuf::rt::value_size(12, self.bottom_boundary, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.day_time != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::DayTime::DAY) {
            my_size += ::protobuf::rt::enum_or_unknown_size(13, self.day_time);
        }
        if self.object_count != 0 {
            my_size += ::protobuf::rt::value_size(14, self.object_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sound_effect_count != 0 {
            my_size += ::protobuf::rt::value_size(15, self.sound_effect_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snake_block_count != 0 {
            my_size += ::protobuf::rt::value_size(16, self.snake_block_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.clear_pipe_count != 0 {
            my_size += ::protobuf::rt::value_size(17, self.clear_pipe_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.piranha_creeper_count != 0 {
            my_size += ::protobuf::rt::value_size(18, self.piranha_creeper_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exclamation_block_count != 0 {
            my_size += ::protobuf::rt::value_size(19, self.exclamation_block_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.track_block_count != 0 {
            my_size += ::protobuf::rt::value_size(20, self.track_block_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tile_count != 0 {
            my_size += ::protobuf::rt::value_size(21, self.tile_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.track_count != 0 {
            my_size += ::protobuf::rt::value_size(22, self.track_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.icicle_count != 0 {
            my_size += ::protobuf::rt::value_size(23, self.icicle_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.course_theme != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::CourseTheme::GROUND) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.course_theme))?;
        }
        if self.auto_scroll != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::AutoScroll::NONE) {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&self.auto_scroll))?;
        }
        if self.screen_boundary != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::ScreenBoundary::ABOVE_LINE) {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&self.screen_boundary))?;
        }
        if self.orientation != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::Orientation::HORIZONTAL) {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&self.orientation))?;
        }
        if self.liquid_max != 0 {
            os.write_uint32(5, self.liquid_max)?;
        }
        if self.liquid_mode != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::LiquidMode::FIXED) {
            os.write_enum(6, ::protobuf::ProtobufEnumOrUnknown::value(&self.liquid_mode))?;
        }
        if self.liquid_speed != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::LiquidSpeed::NONE) {
            os.write_enum(7, ::protobuf::ProtobufEnumOrUnknown::value(&self.liquid_speed))?;
        }
        if self.liquid_min != 0 {
            os.write_uint32(8, self.liquid_min)?;
        }
        if self.right_boundary != 0 {
            os.write_uint32(9, self.right_boundary)?;
        }
        if self.top_boundary != 0 {
            os.write_uint32(10, self.top_boundary)?;
        }
        if self.left_boundary != 0 {
            os.write_uint32(11, self.left_boundary)?;
        }
        if self.bottom_boundary != 0 {
            os.write_uint32(12, self.bottom_boundary)?;
        }
        if self.day_time != ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::DayTime::DAY) {
            os.write_enum(13, ::protobuf::ProtobufEnumOrUnknown::value(&self.day_time))?;
        }
        if self.object_count != 0 {
            os.write_uint32(14, self.object_count)?;
        }
        if self.sound_effect_count != 0 {
            os.write_uint32(15, self.sound_effect_count)?;
        }
        if self.snake_block_count != 0 {
            os.write_uint32(16, self.snake_block_count)?;
        }
        if self.clear_pipe_count != 0 {
            os.write_uint32(17, self.clear_pipe_count)?;
        }
        if self.piranha_creeper_count != 0 {
            os.write_uint32(18, self.piranha_creeper_count)?;
        }
        if self.exclamation_block_count != 0 {
            os.write_uint32(19, self.exclamation_block_count)?;
        }
        if self.track_block_count != 0 {
            os.write_uint32(20, self.track_block_count)?;
        }
        if self.tile_count != 0 {
            os.write_uint32(21, self.tile_count)?;
        }
        if self.track_count != 0 {
            os.write_uint32(22, self.track_count)?;
        }
        if self.icicle_count != 0 {
            os.write_uint32(23, self.icicle_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SMM2CourseArea {
        SMM2CourseArea::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static SMM2CourseArea {
        static instance: SMM2CourseArea = SMM2CourseArea {
            course_theme: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            auto_scroll: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            screen_boundary: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            orientation: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            liquid_max: 0,
            liquid_mode: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            liquid_speed: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            liquid_min: 0,
            right_boundary: 0,
            top_boundary: 0,
            left_boundary: 0,
            bottom_boundary: 0,
            day_time: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            object_count: 0,
            sound_effect_count: 0,
            snake_block_count: 0,
            clear_pipe_count: 0,
            piranha_creeper_count: 0,
            exclamation_block_count: 0,
            track_block_count: 0,
            tile_count: 0,
            track_count: 0,
            icicle_count: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SMM2CourseArea {
    fn clear(&mut self) {
        self.course_theme = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::CourseTheme::GROUND);
        self.auto_scroll = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::AutoScroll::NONE);
        self.screen_boundary = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::ScreenBoundary::ABOVE_LINE);
        self.orientation = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::Orientation::HORIZONTAL);
        self.liquid_max = 0;
        self.liquid_mode = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::LiquidMode::FIXED);
        self.liquid_speed = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::LiquidSpeed::NONE);
        self.liquid_min = 0;
        self.right_boundary = 0;
        self.top_boundary = 0;
        self.left_boundary = 0;
        self.bottom_boundary = 0;
        self.day_time = ::protobuf::ProtobufEnumOrUnknown::new(smm2course_area::DayTime::DAY);
        self.object_count = 0;
        self.sound_effect_count = 0;
        self.snake_block_count = 0;
        self.clear_pipe_count = 0;
        self.piranha_creeper_count = 0;
        self.exclamation_block_count = 0;
        self.track_block_count = 0;
        self.tile_count = 0;
        self.track_count = 0;
        self.icicle_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SMM2CourseArea {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SMM2CourseArea {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SMM2CourseArea`
pub mod smm2course_area {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum CourseTheme {
        GROUND = 0,
        UNDERGROUND = 1,
        CASTLE = 2,
        AIRSHIP = 3,
        UNDERWATER = 4,
        GHOUST_HOUSE = 5,
        SNOW = 6,
        DESERT = 7,
        SKY = 8,
        FOREST = 9,
    }

    impl ::protobuf::ProtobufEnum for CourseTheme {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CourseTheme> {
            match value {
                0 => ::std::option::Option::Some(CourseTheme::GROUND),
                1 => ::std::option::Option::Some(CourseTheme::UNDERGROUND),
                2 => ::std::option::Option::Some(CourseTheme::CASTLE),
                3 => ::std::option::Option::Some(CourseTheme::AIRSHIP),
                4 => ::std::option::Option::Some(CourseTheme::UNDERWATER),
                5 => ::std::option::Option::Some(CourseTheme::GHOUST_HOUSE),
                6 => ::std::option::Option::Some(CourseTheme::SNOW),
                7 => ::std::option::Option::Some(CourseTheme::DESERT),
                8 => ::std::option::Option::Some(CourseTheme::SKY),
                9 => ::std::option::Option::Some(CourseTheme::FOREST),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [CourseTheme] = &[
                CourseTheme::GROUND,
                CourseTheme::UNDERGROUND,
                CourseTheme::CASTLE,
                CourseTheme::AIRSHIP,
                CourseTheme::UNDERWATER,
                CourseTheme::GHOUST_HOUSE,
                CourseTheme::SNOW,
                CourseTheme::DESERT,
                CourseTheme::SKY,
                CourseTheme::FOREST,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 2)
        }
    }

    impl ::std::default::Default for CourseTheme {
        fn default() -> Self {
            CourseTheme::GROUND
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CourseTheme {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl CourseTheme {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<CourseTheme>("SMM2CourseArea.CourseTheme", 2)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum AutoScroll {
        NONE = 0,
        SLOW = 1,
        MEDIUM = 2,
        FAST = 3,
        CUSTOM = 4,
    }

    impl ::protobuf::ProtobufEnum for AutoScroll {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AutoScroll> {
            match value {
                0 => ::std::option::Option::Some(AutoScroll::NONE),
                1 => ::std::option::Option::Some(AutoScroll::SLOW),
                2 => ::std::option::Option::Some(AutoScroll::MEDIUM),
                3 => ::std::option::Option::Some(AutoScroll::FAST),
                4 => ::std::option::Option::Some(AutoScroll::CUSTOM),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [AutoScroll] = &[
                AutoScroll::NONE,
                AutoScroll::SLOW,
                AutoScroll::MEDIUM,
                AutoScroll::FAST,
                AutoScroll::CUSTOM,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 3)
        }
    }

    impl ::std::default::Default for AutoScroll {
        fn default() -> Self {
            AutoScroll::NONE
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutoScroll {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl AutoScroll {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<AutoScroll>("SMM2CourseArea.AutoScroll", 3)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum ScreenBoundary {
        ABOVE_LINE = 0,
        UNDER_LINE = 1,
    }

    impl ::protobuf::ProtobufEnum for ScreenBoundary {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ScreenBoundary> {
            match value {
                0 => ::std::option::Option::Some(ScreenBoundary::ABOVE_LINE),
                1 => ::std::option::Option::Some(ScreenBoundary::UNDER_LINE),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ScreenBoundary] = &[
                ScreenBoundary::ABOVE_LINE,
                ScreenBoundary::UNDER_LINE,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 4)
        }
    }

    impl ::std::default::Default for ScreenBoundary {
        fn default() -> Self {
            ScreenBoundary::ABOVE_LINE
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ScreenBoundary {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl ScreenBoundary {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ScreenBoundary>("SMM2CourseArea.ScreenBoundary", 4)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum Orientation {
        HORIZONTAL = 0,
        VERTICAL = 1,
    }

    impl ::protobuf::ProtobufEnum for Orientation {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Orientation> {
            match value {
                0 => ::std::option::Option::Some(Orientation::HORIZONTAL),
                1 => ::std::option::Option::Some(Orientation::VERTICAL),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [Orientation] = &[
                Orientation::HORIZONTAL,
                Orientation::VERTICAL,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 5)
        }
    }

    impl ::std::default::Default for Orientation {
        fn default() -> Self {
            Orientation::HORIZONTAL
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Orientation {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl Orientation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<Orientation>("SMM2CourseArea.Orientation", 5)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum LiquidMode {
        FIXED = 0,
        ONE_WAY = 1,
        OSCILLATING = 2,
    }

    impl ::protobuf::ProtobufEnum for LiquidMode {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LiquidMode> {
            match value {
                0 => ::std::option::Option::Some(LiquidMode::FIXED),
                1 => ::std::option::Option::Some(LiquidMode::ONE_WAY),
                2 => ::std::option::Option::Some(LiquidMode::OSCILLATING),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [LiquidMode] = &[
                LiquidMode::FIXED,
                LiquidMode::ONE_WAY,
                LiquidMode::OSCILLATING,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 6)
        }
    }

    impl ::std::default::Default for LiquidMode {
        fn default() -> Self {
            LiquidMode::FIXED
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiquidMode {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl LiquidMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<LiquidMode>("SMM2CourseArea.LiquidMode", 6)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum LiquidSpeed {
        NONE = 0,
        SLOW = 1,
        MEDIUM = 2,
        FAST = 3,
    }

    impl ::protobuf::ProtobufEnum for LiquidSpeed {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LiquidSpeed> {
            match value {
                0 => ::std::option::Option::Some(LiquidSpeed::NONE),
                1 => ::std::option::Option::Some(LiquidSpeed::SLOW),
                2 => ::std::option::Option::Some(LiquidSpeed::MEDIUM),
                3 => ::std::option::Option::Some(LiquidSpeed::FAST),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [LiquidSpeed] = &[
                LiquidSpeed::NONE,
                LiquidSpeed::SLOW,
                LiquidSpeed::MEDIUM,
                LiquidSpeed::FAST,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 7)
        }
    }

    impl ::std::default::Default for LiquidSpeed {
        fn default() -> Self {
            LiquidSpeed::NONE
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiquidSpeed {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl LiquidSpeed {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<LiquidSpeed>("SMM2CourseArea.LiquidSpeed", 7)
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(Serialize, Deserialize)]
    pub enum DayTime {
        DAY = 0,
        UNKNOWN0 = 1,
        NIGHT = 2,
        UNKNOWN1 = 3,
    }

    impl ::protobuf::ProtobufEnum for DayTime {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DayTime> {
            match value {
                0 => ::std::option::Option::Some(DayTime::DAY),
                1 => ::std::option::Option::Some(DayTime::UNKNOWN0),
                2 => ::std::option::Option::Some(DayTime::NIGHT),
                3 => ::std::option::Option::Some(DayTime::UNKNOWN1),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [DayTime] = &[
                DayTime::DAY,
                DayTime::UNKNOWN0,
                DayTime::NIGHT,
                DayTime::UNKNOWN1,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 8)
        }
    }

    impl ::std::default::Default for DayTime {
        fn default() -> Self {
            DayTime::DAY
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DayTime {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl DayTime {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<DayTime>("SMM2CourseArea.DayTime", 8)
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10SMM2Course.proto\x12\x05smmdb\"\xd8\x01\n\nSMM2Course\x12\x1a\n\
    \x07version\x18\x01\x20\x01(\rR\x07versionB\0\x121\n\x06header\x18\x02\
    \x20\x01(\x0b2\x17.smmdb.SMM2CourseHeaderR\x06headerB\0\x128\n\x0bcourse\
    _area\x18\x03\x20\x01(\x0b2\x15.smmdb.SMM2CourseAreaR\ncourseAreaB\0\x12\
    ?\n\x0fcourse_sub_area\x18\x04\x20\x01(\x0b2\x15.smmdb.SMM2CourseAreaR\r\
    courseSubAreaB\0:\0\"\x8d\x07\n\x10SMM2CourseHeader\x12\x1c\n\x08modifie\
    d\x18\x01\x20\x01(\x04R\x08modifiedB\0\x12\x16\n\x05title\x18\x02\x20\
    \x01(\tR\x05titleB\0\x12\"\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescr\
    iptionB\0\x12\x19\n\x07start_y\x18\x04\x20\x01(\rR\x06startYB\0\x12\x1b\
    \n\x08finish_y\x18\x05\x20\x01(\rR\x07finishYB\0\x12\x1b\n\x08finish_x\
    \x18\x06\x20\x01(\rR\x07finishXB\0\x12\x14\n\x04time\x18\x07\x20\x01(\rR\
    \x04timeB\0\x12B\n\ngame_style\x18\x08\x20\x01(\x0e2!.smmdb.SMM2CourseHe\
    ader.GameStyleR\tgameStyleB\0\x12^\n\x14clear_condition_type\x18\t\x20\
    \x01(\x0e2*.smmdb.SMM2CourseHeader.ClearConditionTypeR\x12clearCondition\
    TypeB\0\x12)\n\x0fclear_condition\x18\n\x20\x01(\rR\x0eclearConditionB\0\
    \x126\n\x16clear_condition_amount\x18\x0b\x20\x01(\rR\x14clearConditionA\
    mountB\0\x12,\n\x11clear_check_tries\x18\x0c\x20\x01(\rR\x0fclearCheckTr\
    iesB\0\x12*\n\x10clear_check_time\x18\r\x20\x01(\rR\x0eclearCheckTimeB\0\
    \x12#\n\x0cgame_version\x18\x0e\x20\x01(\rR\x0bgameVersionB\0\x12+\n\x10\
    management_flags\x18\x0f\x20\x01(\rR\x0fmanagementFlagsB\0\x12!\n\x0bcre\
    ation_id\x18\x10\x20\x01(\rR\ncreationIdB\0\x12\x1d\n\tupload_id\x18\x11\
    \x20\x01(\x04R\x08uploadIdB\0\x12/\n\x12completion_version\x18\x12\x20\
    \x01(\rR\x11completionVersionB\0\"?\n\tGameStyle\x12\x08\n\x02M1\x10\0\
    \x1a\0\x12\x08\n\x02M3\x10\x01\x1a\0\x12\x08\n\x02MW\x10\x02\x1a\0\x12\
    \x08\n\x02WU\x10\x03\x1a\0\x12\x08\n\x02W3\x10\x04\x1a\0\x1a\0\"K\n\x12C\
    learConditionType\x12\n\n\x04NONE\x10\0\x1a\0\x12\x0b\n\x05PARTS\x10\x01\
    \x1a\0\x12\x0c\n\x06STATUS\x10\x02\x1a\0\x12\x0c\n\x06ACTION\x10\x03\x1a\
    \0\x1a\0:\0\"\xc3\r\n\x0eSMM2CourseArea\x12F\n\x0ccourse_theme\x18\x01\
    \x20\x01(\x0e2!.smmdb.SMM2CourseArea.CourseThemeR\x0bcourseThemeB\0\x12C\
    \n\x0bauto_scroll\x18\x02\x20\x01(\x0e2\x20.smmdb.SMM2CourseArea.AutoScr\
    ollR\nautoScrollB\0\x12O\n\x0fscreen_boundary\x18\x03\x20\x01(\x0e2$.smm\
    db.SMM2CourseArea.ScreenBoundaryR\x0escreenBoundaryB\0\x12E\n\x0borienta\
    tion\x18\x04\x20\x01(\x0e2!.smmdb.SMM2CourseArea.OrientationR\x0borienta\
    tionB\0\x12\x1f\n\nliquid_max\x18\x05\x20\x01(\rR\tliquidMaxB\0\x12C\n\
    \x0bliquid_mode\x18\x06\x20\x01(\x0e2\x20.smmdb.SMM2CourseArea.LiquidMod\
    eR\nliquidModeB\0\x12F\n\x0cliquid_speed\x18\x07\x20\x01(\x0e2!.smmdb.SM\
    M2CourseArea.LiquidSpeedR\x0bliquidSpeedB\0\x12\x1f\n\nliquid_min\x18\
    \x08\x20\x01(\rR\tliquidMinB\0\x12'\n\x0eright_boundary\x18\t\x20\x01(\r\
    R\rrightBoundaryB\0\x12#\n\x0ctop_boundary\x18\n\x20\x01(\rR\x0btopBound\
    aryB\0\x12%\n\rleft_boundary\x18\x0b\x20\x01(\rR\x0cleftBoundaryB\0\x12)\
    \n\x0fbottom_boundary\x18\x0c\x20\x01(\rR\x0ebottomBoundaryB\0\x12:\n\
    \x08day_time\x18\r\x20\x01(\x0e2\x1d.smmdb.SMM2CourseArea.DayTimeR\x07da\
    yTimeB\0\x12#\n\x0cobject_count\x18\x0e\x20\x01(\rR\x0bobjectCountB\0\
    \x12.\n\x12sound_effect_count\x18\x0f\x20\x01(\rR\x10soundEffectCountB\0\
    \x12,\n\x11snake_block_count\x18\x10\x20\x01(\rR\x0fsnakeBlockCountB\0\
    \x12*\n\x10clear_pipe_count\x18\x11\x20\x01(\rR\x0eclearPipeCountB\0\x12\
    4\n\x15piranha_creeper_count\x18\x12\x20\x01(\rR\x13piranhaCreeperCountB\
    \0\x128\n\x17exclamation_block_count\x18\x13\x20\x01(\rR\x15exclamationB\
    lockCountB\0\x12,\n\x11track_block_count\x18\x14\x20\x01(\rR\x0ftrackBlo\
    ckCountB\0\x12\x1f\n\ntile_count\x18\x15\x20\x01(\rR\ttileCountB\0\x12!\
    \n\x0btrack_count\x18\x16\x20\x01(\rR\ntrackCountB\0\x12#\n\x0cicicle_co\
    unt\x18\x17\x20\x01(\rR\x0bicicleCountB\0\"\xa6\x01\n\x0bCourseTheme\x12\
    \x0c\n\x06GROUND\x10\0\x1a\0\x12\x11\n\x0bUNDERGROUND\x10\x01\x1a\0\x12\
    \x0c\n\x06CASTLE\x10\x02\x1a\0\x12\r\n\x07AIRSHIP\x10\x03\x1a\0\x12\x10\
    \n\nUNDERWATER\x10\x04\x1a\0\x12\x12\n\x0cGHOUST_HOUSE\x10\x05\x1a\0\x12\
    \n\n\x04SNOW\x10\x06\x1a\0\x12\x0c\n\x06DESERT\x10\x07\x1a\0\x12\t\n\x03\
    SKY\x10\x08\x1a\0\x12\x0c\n\x06FOREST\x10\t\x1a\0\x1a\0\"N\n\nAutoScroll\
    \x12\n\n\x04NONE\x10\0\x1a\0\x12\n\n\x04SLOW\x10\x01\x1a\0\x12\x0c\n\x06\
    MEDIUM\x10\x02\x1a\0\x12\n\n\x04FAST\x10\x03\x1a\0\x12\x0c\n\x06CUSTOM\
    \x10\x04\x1a\0\x1a\0\"6\n\x0eScreenBoundary\x12\x10\n\nABOVE_LINE\x10\0\
    \x1a\0\x12\x10\n\nUNDER_LINE\x10\x01\x1a\0\x1a\0\"1\n\x0bOrientation\x12\
    \x10\n\nHORIZONTAL\x10\0\x1a\0\x12\x0e\n\x08VERTICAL\x10\x01\x1a\0\x1a\0\
    \"=\n\nLiquidMode\x12\x0b\n\x05FIXED\x10\0\x1a\0\x12\r\n\x07ONE_WAY\x10\
    \x01\x1a\0\x12\x11\n\x0bOSCILLATING\x10\x02\x1a\0\x1a\0\"A\n\x0bLiquidSp\
    eed\x12\n\n\x04NONE\x10\0\x1a\0\x12\n\n\x04SLOW\x10\x01\x1a\0\x12\x0c\n\
    \x06MEDIUM\x10\x02\x1a\0\x12\n\n\x04FAST\x10\x03\x1a\0\x1a\0\"C\n\x07Day\
    Time\x12\t\n\x03DAY\x10\0\x1a\0\x12\x0e\n\x08UNKNOWN0\x10\x01\x1a\0\x12\
    \x0b\n\x05NIGHT\x10\x02\x1a\0\x12\x0e\n\x08UNKNOWN1\x10\x03\x1a\0\x1a\0:\
    \0B\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(SMM2Course::generated_message_descriptor_data());
        messages.push(SMM2CourseHeader::generated_message_descriptor_data());
        messages.push(SMM2CourseArea::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(smm2course_header::GameStyle::generated_enum_descriptor_data());
        enums.push(smm2course_header::ClearConditionType::generated_enum_descriptor_data());
        enums.push(smm2course_area::CourseTheme::generated_enum_descriptor_data());
        enums.push(smm2course_area::AutoScroll::generated_enum_descriptor_data());
        enums.push(smm2course_area::ScreenBoundary::generated_enum_descriptor_data());
        enums.push(smm2course_area::Orientation::generated_enum_descriptor_data());
        enums.push(smm2course_area::LiquidMode::generated_enum_descriptor_data());
        enums.push(smm2course_area::LiquidSpeed::generated_enum_descriptor_data());
        enums.push(smm2course_area::DayTime::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
